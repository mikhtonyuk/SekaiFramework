<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Sekai Framework: D:/Programming/Projects/depot/SekaiFramework/src/reflection/delegate/Delegate_closure.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>D:/Programming/Projects/depot/SekaiFramework/src/reflection/delegate/Delegate_closure.h</h1><a href="_delegate__closure_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//                                              ClosurePtr&lt;&gt;</span>
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// A private wrapper class that adds function signatures to FunctionData.</span>
<a name="l00004"></a>00004 <span class="comment">// It&apos;s the class that does most of the actual work.</span>
<a name="l00005"></a>00005 <span class="comment">// The signatures are specified by:</span>
<a name="l00006"></a>00006 <span class="comment">// GenericMemFunc: must be a type of GenericClass member function pointer. </span>
<a name="l00007"></a>00007 <span class="comment">// StaticFuncPtr:  must be a type of function pointer with the same signature </span>
<a name="l00008"></a>00008 <span class="comment">//                 as GenericMemFunc.</span>
<a name="l00009"></a>00009 <span class="comment">// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6</span>
<a name="l00010"></a>00010 <span class="comment">//                 where it never returns void (returns DefaultVoid instead).</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="comment">// An outer class, DelegateN&lt;&gt;, handles the invoking and creates the</span>
<a name="l00013"></a>00013 <span class="comment">// necessary typedefs.</span>
<a name="l00014"></a>00014 <span class="comment">// This class does everything else.</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">namespace </span>detail {
<a name="l00017"></a>00017 
<a name="l00018"></a>00018         <span class="keyword">template</span> &lt; <span class="keyword">class</span> GenericMemFunc, <span class="keyword">class</span> StaticFuncPtr, <span class="keyword">class</span> Un<span class="keywordtype">void</span>StaticFuncPtr&gt;
<a name="l00019"></a><a class="code" href="classdetail_1_1_closure_ptr.html">00019</a>         <span class="keyword">class </span><a class="code" href="classdetail_1_1_closure_ptr.html">ClosurePtr</a> : <span class="keyword">public</span> <a class="code" href="class_function_data.html">FunctionData</a> 
<a name="l00020"></a>00020         {
<a name="l00021"></a>00021         <span class="keyword">public</span>:
<a name="l00022"></a>00022                 <span class="comment">// These functions are for setting the delegate to a member function.</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024                 <span class="comment">// Here&apos;s the clever bit: we convert an arbitrary member function into a </span>
<a name="l00025"></a>00025                 <span class="comment">// standard form. XMemFunc should be a member function of class X, but I can&apos;t </span>
<a name="l00026"></a>00026                 <span class="comment">// enforce that here. It needs to be enforced by the wrapper class.</span>
<a name="l00027"></a>00027                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> XMemFunc &gt;
<a name="l00028"></a><a class="code" href="classdetail_1_1_closure_ptr.html#a270f7b986690d351f559584454406afc">00028</a>                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdetail_1_1_closure_ptr.html#a270f7b986690d351f559584454406afc">bindmemfunc</a>(X *pthis, XMemFunc function_to_bind ) 
<a name="l00029"></a>00029                 {
<a name="l00030"></a>00030                         <a class="code" href="class_function_data.html#ab6f1f5c766267e7a4a121af01f83cc5c">m_pthis</a> = <a class="code" href="structdetail_1_1_simplify_mem_func.html">SimplifyMemFunc&lt; sizeof(function_to_bind) &gt;::Convert</a>(pthis, function_to_bind, <a class="code" href="class_function_data.html#a917bd596ea302f71db255275abbd8c7a">m_pFunction</a>);
<a name="l00031"></a>00031 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>                        m_pStaticFunction = 0;
<a name="l00033"></a>00033 <span class="preprocessor">#endif</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>                }
<a name="l00035"></a>00035                 <span class="comment">// For const member functions, we only need a const class pointer.</span>
<a name="l00036"></a>00036                 <span class="comment">// Since we know that the member function is const, it&apos;s safe to </span>
<a name="l00037"></a>00037                 <span class="comment">// remove the const qualifier from the &apos;this&apos; pointer with a const_cast.</span>
<a name="l00038"></a>00038                 <span class="comment">// VC6 has problems if we just overload &apos;bindmemfunc&apos;, so we give it a different name.</span>
<a name="l00039"></a>00039                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> XMemFunc&gt;
<a name="l00040"></a><a class="code" href="classdetail_1_1_closure_ptr.html#ab45dca28fcf73ae5e41da56b4df08b57">00040</a>                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdetail_1_1_closure_ptr.html#ab45dca28fcf73ae5e41da56b4df08b57">bindconstmemfunc</a>(<span class="keyword">const</span> X *pthis, XMemFunc function_to_bind)
<a name="l00041"></a>00041                 {
<a name="l00042"></a>00042                         <a class="code" href="class_function_data.html#ab6f1f5c766267e7a4a121af01f83cc5c">m_pthis</a>= <a class="code" href="structdetail_1_1_simplify_mem_func.html">SimplifyMemFunc&lt; sizeof(function_to_bind) &gt;::Convert</a>(<span class="keyword">const_cast&lt;</span>X*<span class="keyword">&gt;</span>(pthis), function_to_bind, <a class="code" href="class_function_data.html#a917bd596ea302f71db255275abbd8c7a">m_pFunction</a>);
<a name="l00043"></a>00043 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>                        m_pStaticFunction = 0;
<a name="l00045"></a>00045 <span class="preprocessor">#endif</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>                }
<a name="l00047"></a>00047 <span class="preprocessor">#ifdef FASTDELEGATE_GCC_BUG_8271        // At present, GCC doesn&apos;t recognize constness of MFPs in templates</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>                <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> XMemFunc&gt;
<a name="l00049"></a>00049                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdetail_1_1_closure_ptr.html#a270f7b986690d351f559584454406afc">bindmemfunc</a>(<span class="keyword">const</span> X *pthis, XMemFunc function_to_bind) 
<a name="l00050"></a>00050                 {
<a name="l00051"></a>00051                         <a class="code" href="classdetail_1_1_closure_ptr.html#ab45dca28fcf73ae5e41da56b4df08b57">bindconstmemfunc</a>(pthis, function_to_bind);
<a name="l00052"></a>00052 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>                        m_pStaticFunction = 0;
<a name="l00054"></a>00054 <span class="preprocessor">#endif</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>                }
<a name="l00056"></a>00056 <span class="preprocessor">#endif</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>                <span class="comment">// These functions are required for invoking the stored function</span>
<a name="l00058"></a><a class="code" href="classdetail_1_1_closure_ptr.html#a3a07b0ea4a68d1b4d962a561dc4d6b48">00058</a>                 <span class="keyword">inline</span> GenericMemFunc <a class="code" href="classdetail_1_1_closure_ptr.html#a3a07b0ea4a68d1b4d962a561dc4d6b48">GetClosureMemPtr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>GenericMemFunc<span class="keyword">&gt;</span>(<a class="code" href="class_function_data.html#a917bd596ea302f71db255275abbd8c7a">m_pFunction</a>); }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060                 <span class="comment">// There are a few ways of dealing with static function pointers.</span>
<a name="l00061"></a>00061                 <span class="comment">// There&apos;s a standard-compliant, but tricky method.</span>
<a name="l00062"></a>00062                 <span class="comment">// There&apos;s also a straightforward hack, that won&apos;t work on DOS compilers using the</span>
<a name="l00063"></a>00063                 <span class="comment">// medium memory model. It&apos;s so evil that I can&apos;t recommend it, but I&apos;ve</span>
<a name="l00064"></a>00064                 <span class="comment">// implemented it anyway because it produces very nice asm code.</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068                 <span class="comment">//                              ClosurePtr&lt;&gt; - Safe version</span>
<a name="l00069"></a>00069                 <span class="comment">//</span>
<a name="l00070"></a>00070                 <span class="comment">// This implementation is standard-compliant, but a bit tricky.</span>
<a name="l00071"></a>00071                 <span class="comment">// I store the function pointer inside the class, and the delegate then</span>
<a name="l00072"></a>00072                 <span class="comment">// points to itself. Whenever the delegate is copied, these self-references</span>
<a name="l00073"></a>00073                 <span class="comment">// must be transformed, and this complicates the = and == operators.</span>
<a name="l00074"></a>00074         <span class="keyword">public</span>:
<a name="l00075"></a>00075                 <span class="comment">// The next two functions are for operator ==, =, and the copy constructor.</span>
<a name="l00076"></a>00076                 <span class="comment">// We may need to convert the m_pthis pointers, so that</span>
<a name="l00077"></a>00077                 <span class="comment">// they remain as self-references.</span>
<a name="l00078"></a>00078                 <span class="keyword">template</span>&lt; <span class="keyword">class</span> DerivedClass &gt;
<a name="l00079"></a>00079                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdetail_1_1_closure_ptr.html#a5382fb32bfb07cf143b109d8a8f3d671">CopyFrom</a> (DerivedClass *pParent, <span class="keyword">const</span> <a class="code" href="class_function_data.html">FunctionData</a> &amp;x) 
<a name="l00080"></a>00080                 {
<a name="l00081"></a>00081                         <a class="code" href="class_function_data.html#aaab9a69d73da6c878e5ce86a9c46087f">SetFunctionDataFrom</a>(x);
<a name="l00082"></a>00082                         <span class="keywordflow">if</span> (m_pStaticFunction!=0) 
<a name="l00083"></a>00083                         {
<a name="l00084"></a>00084                                 <span class="comment">// transform self references...</span>
<a name="l00085"></a>00085                                 <a class="code" href="class_function_data.html#ab6f1f5c766267e7a4a121af01f83cc5c">m_pthis</a>=<span class="keyword">reinterpret_cast&lt;</span>GenericClass *<span class="keyword">&gt;</span>(pParent);
<a name="l00086"></a>00086                         }
<a name="l00087"></a>00087                 }
<a name="l00088"></a>00088                 <span class="comment">// For static functions, the &apos;static_function_invoker&apos; class in the parent </span>
<a name="l00089"></a>00089                 <span class="comment">// will be called. The parent then needs to call GetStaticFunction() to find out </span>
<a name="l00090"></a>00090                 <span class="comment">// the actual function to invoke.</span>
<a name="l00091"></a>00091                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> DerivedClass, <span class="keyword">class</span> ParentInvokerSig &gt;
<a name="l00092"></a>00092                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdetail_1_1_closure_ptr.html#a3a84788dd9b096b01f0b33453b5924db">bindstaticfunc</a>(DerivedClass *pParent, ParentInvokerSig static_function_invoker, StaticFuncPtr function_to_bind ) 
<a name="l00093"></a>00093                 {
<a name="l00094"></a>00094                         <span class="keywordflow">if</span> (function_to_bind==0) { <span class="comment">// cope with assignment to 0</span>
<a name="l00095"></a>00095                                 <a class="code" href="class_function_data.html#a917bd596ea302f71db255275abbd8c7a">m_pFunction</a>=0;
<a name="l00096"></a>00096                         } <span class="keywordflow">else</span> { 
<a name="l00097"></a>00097                                 <a class="code" href="classdetail_1_1_closure_ptr.html#a270f7b986690d351f559584454406afc">bindmemfunc</a>(pParent, static_function_invoker);
<a name="l00098"></a>00098                         }
<a name="l00099"></a>00099                         m_pStaticFunction=<span class="keyword">reinterpret_cast&lt;</span>GenericFuncPtr<span class="keyword">&gt;</span>(function_to_bind);
<a name="l00100"></a>00100                 }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102                 <span class="keyword">inline</span> UnvoidStaticFuncPtr <a class="code" href="classdetail_1_1_closure_ptr.html#ab766c0854cf19461c81eb2a18579f4c9">GetStaticFunction</a>()<span class="keyword"> const </span>
<a name="l00103"></a>00103 <span class="keyword">                </span>{ 
<a name="l00104"></a>00104                         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>UnvoidStaticFuncPtr<span class="keyword">&gt;</span>(m_pStaticFunction); 
<a name="l00105"></a>00105                 }
<a name="l00106"></a>00106 <span class="preprocessor">#else</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>
<a name="l00108"></a>00108                 <span class="comment">//                              ClosurePtr&lt;&gt; - Evil version</span>
<a name="l00109"></a>00109                 <span class="comment">//</span>
<a name="l00110"></a>00110                 <span class="comment">// For compilers where data pointers are at least as big as code pointers, it is </span>
<a name="l00111"></a>00111                 <span class="comment">// possible to store the function pointer in the this pointer, using another </span>
<a name="l00112"></a>00112                 <span class="comment">// horrible_cast. Invocation isn&apos;t any faster, but it saves 4 bytes, and</span>
<a name="l00113"></a>00113                 <span class="comment">// speeds up comparison and assignment. If C++ provided direct language support</span>
<a name="l00114"></a>00114                 <span class="comment">// for delegates, they would produce asm code that was almost identical to this.</span>
<a name="l00115"></a>00115                 <span class="comment">// Note that the Sun C++ and MSVC documentation explicitly state that they </span>
<a name="l00116"></a>00116                 <span class="comment">// support static_cast between void * and function pointers.</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118                 <span class="keyword">template</span>&lt; <span class="keyword">class</span> DerivedClass &gt;
<a name="l00119"></a><a class="code" href="classdetail_1_1_closure_ptr.html#a5382fb32bfb07cf143b109d8a8f3d671">00119</a>                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdetail_1_1_closure_ptr.html#a5382fb32bfb07cf143b109d8a8f3d671">CopyFrom</a> (DerivedClass *pParent, <span class="keyword">const</span> <a class="code" href="class_function_data.html">FunctionData</a> &amp;right) 
<a name="l00120"></a>00120                 {
<a name="l00121"></a>00121                         <a class="code" href="class_function_data.html#aaab9a69d73da6c878e5ce86a9c46087f">SetFunctionDataFrom</a>(right);
<a name="l00122"></a>00122                 }
<a name="l00123"></a>00123                 <span class="comment">// For static functions, the &apos;static_function_invoker&apos; class in the parent </span>
<a name="l00124"></a>00124                 <span class="comment">// will be called. The parent then needs to call GetStaticFunction() to find out </span>
<a name="l00125"></a>00125                 <span class="comment">// the actual function to invoke.</span>
<a name="l00126"></a>00126                 <span class="comment">// ******** EVIL, EVIL CODE! *******</span>
<a name="l00127"></a>00127                 <span class="keyword">template</span> &lt;      <span class="keyword">class</span> DerivedClass, <span class="keyword">class</span> ParentInvokerSig&gt;
<a name="l00128"></a><a class="code" href="classdetail_1_1_closure_ptr.html#a3a84788dd9b096b01f0b33453b5924db">00128</a>                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdetail_1_1_closure_ptr.html#a3a84788dd9b096b01f0b33453b5924db">bindstaticfunc</a>(DerivedClass *pParent, ParentInvokerSig static_function_invoker, StaticFuncPtr function_to_bind) 
<a name="l00129"></a>00129                 {
<a name="l00130"></a>00130                         <span class="keywordflow">if</span> (function_to_bind==0) { <span class="comment">// cope with assignment to 0</span>
<a name="l00131"></a>00131                                 <a class="code" href="class_function_data.html#a917bd596ea302f71db255275abbd8c7a">m_pFunction</a>=0;
<a name="l00132"></a>00132                         } <span class="keywordflow">else</span> { 
<a name="l00133"></a>00133                                 <span class="comment">// We&apos;ll be ignoring the &apos;this&apos; pointer, but we need to make sure we pass</span>
<a name="l00134"></a>00134                                 <span class="comment">// a valid value to bindmemfunc().</span>
<a name="l00135"></a>00135                                 <a class="code" href="classdetail_1_1_closure_ptr.html#a270f7b986690d351f559584454406afc">bindmemfunc</a>(pParent, static_function_invoker);
<a name="l00136"></a>00136                         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138                         <span class="comment">// WARNING! Evil hack. We store the function in the &apos;this&apos; pointer!</span>
<a name="l00139"></a>00139                         <span class="comment">// Ensure that there&apos;s a compilation failure if function pointers </span>
<a name="l00140"></a>00140                         <span class="comment">// and data pointers have different sizes.</span>
<a name="l00141"></a>00141                         <span class="comment">// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.</span>
<a name="l00142"></a>00142                         <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUseEvilMethod[<span class="keyword">sizeof</span>(GenericClass *)==<span class="keyword">sizeof</span>(function_to_bind) ? 1 : -1];
<a name="l00143"></a>00143                         <a class="code" href="class_function_data.html#ab6f1f5c766267e7a4a121af01f83cc5c">m_pthis</a> = <a class="code" href="namespacedetail.html#ab2eb48afd75b673050c7f75c999f4250">horrible_cast</a>&lt;GenericClass *&gt;(function_to_bind);
<a name="l00144"></a>00144                 }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146                 <span class="comment">// ******** EVIL, EVIL CODE! *******</span>
<a name="l00147"></a>00147                 <span class="comment">// This function will be called with an invalid &apos;this&apos; pointer!!</span>
<a name="l00148"></a>00148                 <span class="comment">// We&apos;re just returning the &apos;this&apos; pointer, converted into</span>
<a name="l00149"></a>00149                 <span class="comment">// a function pointer!</span>
<a name="l00150"></a><a class="code" href="classdetail_1_1_closure_ptr.html#ab766c0854cf19461c81eb2a18579f4c9">00150</a>                 <span class="keyword">inline</span> UnvoidStaticFuncPtr <a class="code" href="classdetail_1_1_closure_ptr.html#ab766c0854cf19461c81eb2a18579f4c9">GetStaticFunction</a>()<span class="keyword"> const </span>
<a name="l00151"></a>00151 <span class="keyword">                </span>{
<a name="l00152"></a>00152                         <span class="comment">// Ensure that there&apos;s a compilation failure if function pointers </span>
<a name="l00153"></a>00153                         <span class="comment">// and data pointers have different sizes.</span>
<a name="l00154"></a>00154                         <span class="comment">// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.</span>
<a name="l00155"></a>00155                         <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUseEvilMethod[<span class="keyword">sizeof</span>(UnvoidStaticFuncPtr)==<span class="keyword">sizeof</span>(<span class="keyword">this</span>) ? 1 : -1];
<a name="l00156"></a>00156                         <span class="keywordflow">return</span> <a class="code" href="namespacedetail.html#ab2eb48afd75b673050c7f75c999f4250">horrible_cast</a>&lt;UnvoidStaticFuncPtr&gt;(<span class="keyword">this</span>);
<a name="l00157"></a>00157                 }
<a name="l00158"></a>00158 <span class="preprocessor">#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160                 <span class="comment">// Does the closure contain this static function?</span>
<a name="l00161"></a><a class="code" href="classdetail_1_1_closure_ptr.html#ac9efbef8d81d3c4323ace37647deabbd">00161</a>                 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classdetail_1_1_closure_ptr.html#ac9efbef8d81d3c4323ace37647deabbd">IsEqualToStaticFuncPtr</a>(StaticFuncPtr funcptr)
<a name="l00162"></a>00162                 {
<a name="l00163"></a>00163                         <span class="keywordflow">if</span> (funcptr==0) <span class="keywordflow">return</span> <a class="code" href="class_function_data.html#a2d54a3ff57047dd0761a7c72cc120219">empty</a>(); 
<a name="l00164"></a>00164                         <span class="comment">// For the Evil method, if it doesn&apos;t actually contain a static function, this will return an arbitrary</span>
<a name="l00165"></a>00165                         <span class="comment">// value that is not equal to any valid function pointer.</span>
<a name="l00166"></a>00166                         <span class="keywordflow">else</span> <span class="keywordflow">return</span> funcptr==<span class="keyword">reinterpret_cast&lt;</span>StaticFuncPtr<span class="keyword">&gt;</span>(<a class="code" href="classdetail_1_1_closure_ptr.html#ab766c0854cf19461c81eb2a18579f4c9">GetStaticFunction</a>());
<a name="l00167"></a>00167                 }
<a name="l00168"></a>00168         };
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 } <span class="comment">// namespace detail</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Apr 28 21:26:18 2010 for Sekai Framework by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
